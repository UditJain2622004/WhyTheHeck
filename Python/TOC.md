# Table of Content

|                   File Name                    |          Description           |           Expected Output            |             Actual Output             |                                                                                                                                                                                                                                                                                                                                                             Explanation                                                                                                                                                                                                                                                                                                                                                             |
| :--------------------------------------------: | :----------------------------: | :----------------------------------: | :-----------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|           [none.py](/Python/None.py)           |           No quotes            |                Error                 |                  10                   |                                                                                                                                                                                                                                                        Quotes are not necessary when using `None` because `None` is a special keyword in Python representing the absence of a value, and it is a unique property of the `None` value in Python that it doesn't need quotes.                                                                                                                                                                                                                                                         |
|            [def.py](/Python/def.py)            |        return function         |                Error                 |               No error                |                                                                                                                                                        When you call `cold(6)`, it returns the `hot` function with `a` set to `6`. So, `func` now holds a reference to the `hot` function with `a` set to `6`. When you later call `func(9)`, you are effectively calling the `hot` function with `b` set to `9` (because `a` is already set to `6`). This results in the `"So, I came inside"` message being printed, and it returns the sum of `6` and `9`, which is `15`.                                                                                                                                                        |
|          [devil.py](/Python/devil.py)          |   latin, Cyrillic characters   |                  5                   |                  21                   |                                                                                                                                                                                                                                                         The `a` in line 1 is the `Latin` letter `"a"`. The `a` in lines 2 and 3 is the `Cyrillic` letter `"Ð°"`. We never changed the latin letter `a` and we are printing the latin letter `a` i line 4 which is still 21.                                                                                                                                                                                                                                                          |
|           [else.py](/Python/else.py)           |        else with loops         | Last else block should have executed |   Last else block does not execute    |                                                                                                                                                                                                         The `else` clause with loops is only executed when your loop condition becomes `false`. If you break out of the loop, or if an exception is raised, it won't be executed. That's why the `else` with `for` loop is executed, but in the `while` loop, we break out of the loop. So, `else` block won't be executed.                                                                                                                                                                                                         |
|          [empty.py](/Python/empty.py)          |          empty tuple           |           Length of tuple            |                   0                   |                                                                                                                                                                                                In line 1, we've created an empty tuple named `tuple`. So,`tuple1=tuple\*2` effectively creates another empty tuple since you're repeating an empty tuple, and it doesn't add any elements to the new tuple. As a result, `tuple1` remains an empty tuple, and when you check its length using `len(tuple1)`, it correctly returns 0.                                                                                                                                                                                                |
|         [intent.py](/Python/intent.py)         |       Indentation Error        |                "Yes"                 |           IndentationError            |                                                                                                                                                                                                                                                                     In Python, you must use the same level of indentation for all statements within a code block. In this code, the `if` block and the `else` block should have the same level of indentation.                                                                                                                                                                                                                                                                      |
|             [is.py](/Python/is.py)             |       integer v/s lists        |              True True               |              True False               | In Python, the `is` operator is used to check if two variables reference the same object in memory, i.e., if they are the exact same object.In Python, small integers like 1 are cached, which means that the same integer object is reused for small integer values to save memory. So, when you do `a is b`, it evaluates to `True` because both `a` and `b` reference the same integer object in memory.But when `a` and `b` are assigned lists `[1]`, lists are mutable objects in Python, and each time you create a new list, even if it has the same content, it is a distinct object in memory. So, when you do `a is b`, it evaluates to `False` because `a` and `b` are two different list objects with the same content. |
|           [lazy.py](/Python/lazy.py)           |  Binary representation error   |                 1.0                  |          Program never ends           |                                                                                                                      This behavior is due to how floating-point numbers are represented and stored in computers. In Python, floating-point numbers are represented using the IEEE 754 standard, which uses a binary representation. While `0.1` may seem like a simple decimal number, its binary representation is not exact. When you repeatedly add `0.1` to `x`, you are accumulating small errors in the least significant digits of `x`, which can prevent it from ever becoming exactly equal to `1.0`.                                                                                                                      |
|          [print.py](/Python/print.py)          |            if else             |      How did that get printed?       | Hello World How did that get printed? |                                                                                                                                                                                                                `if print("Hello World") == "FOSS":` first executes the `print` statement and prints `Hello World`. Then the return value of `print` function, i.e. `None`, is compared to string `"FOSS"`, which evaluates to `False`. So the control goes to `else` block and it prints `How did that get printed?`                                                                                                                                                                                                                |
|         [return.py](/Python/return.py)         |            if else             |      Welcome to World of Codes.      |    Welcome to World of Codes. None    |                                                                                                                                                                                                                                                                                  The `None` value is printed because the `welcome` function prints `"Welcome to World of Codes."` and returns what the `print` function returns, which is `None`.                                                                                                                                                                                                                                                                                   |
| [stringMultiply.py](/Python/stringMultiply.py) | Multiplying string with number |              TypeError               |       FOSSFOSSFOSS...(69 times)       |                                                                                                                                                                                                                              This behavior is not an error but a feature of the language. It is an example of operator overloading. Python defines the `*` operator for strings to repeat the string a specified number of times, which is a convenient and intuitive feature for string manipulation.                                                                                                                                                                                                                              |
|            [sum.py](/Python/sum.py)            |   Adding tuple with numbers    |                 10 7                 |               TypeError               |                                                                                                                                                                                                                                                    All the elements of `tuple` are integers, so they can be added together using `sum` function. But the 2nd element of `tuple1` is itself a tuple, which can not be added with numbers. That's why, compiler throws TypeError.                                                                                                                                                                                                                                                     |
|          [upper.py](/Python/upper.py)          |        UpperCase Words         |             ('IM','UR')              |             ('im', 'ur')              |                                                                                                  Tuples in Python are immutable, which means you cannot change their elements after they are created. In your loop, `for i in L:`, `i` is just a temporary variable that takes on the values of the elements in the tuple `L`. When you write `i.upper()`, you are just converting that temporary variable to uppercase. Even if you do `i=i.upper()`, you are creating a new string (the uppercase version of the string) and assigning it to the variable `i`. However, this does not modify the original tuple `L` in any way.                                                                                                   |
